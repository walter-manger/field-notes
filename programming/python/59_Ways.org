#+TITLE: 59 Ways To Improve Python
#+STARTUP: logdone
#+OPTIONS: toc:nil num:nil
#+TODO: TODO IN-PROGRESS | DONE(!)

* Pythonic Thinking

** DONE 1. Know Which Version of Python You're Using
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_src sh
     python --version
     python3 --version
     which python
   #+end_src

   #+RESULTS:
   | Python                            | 3.6.2 |
   | Python                            | 3.6.2 |
   | /Users/------/.pyenv/shims/python |       |

** DONE 2. Follow the PEP (Python Enhancement Proposal) 8 Style Guide
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_quote
   Don't do this manually, use a tool like =autopep8= and =pylint=.
   #+end_quote

*** Naming
    
    - Functions, variables, and attributes should be in =lowercase_underscore= format.
    - Protected instance attributes should be in =_leading_underscore= format.
    - Private instance attributes should be in =__double_leading_underscore= format.
    - Classes and exceptions should be in =CapitalizedWord= format.
    - Module-level constants should be in =ALL_CAPS= format.
    - Instance methods in classes should use =self= as the name of the first parameter (which refers to the object).
    - Class methods should use =cls= as the name of the first parameter (which refers to the class). 

*** Expressions and Statements
    
    - Use inline negation =(if a is not b)= instead of negation of positive expressions =(if not a is b)=
    - Don't check for empty values (like =[]= or =''=) by checking the length =(if len(somelist) == 0=. Use =if not somelist= and assume empty values implicitly evaluate to =False=.
    - The same thing goes for non-empty values (like =[1]= or ='hi'=). The statement =if somelist= is implicitly =True= for non-empty values.
    - Avoid single-line =if= statements, =for= and =while= loops, and =except= compound statements. Spread these over multiple lines for clarity.
    - Always put =import= statements at the top of a file.
    - Always use absolute names for modules when importing them, not names relative to the current module's own path. For example, to import the =foo= module from the =bar= package, you should do =from bar import foo=, not just =import foo=.
    - Imports should be in sections in the following order: standard library modules, third=party modules, your own modules. Each subsection should have imports in alphabetical order.

** DONE 3. Know the Differences Between =bytes=, =str=, and =unicode=
   CLOSED: [2019-05-29 Wed 21:57]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 21:57]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 21:57]
   No need to worry about =unicode= in Python 3. 

   #+begin_src python
     def to_str(bytes_or_str) -> str:
         if isinstance(bytes_or_str, bytes):
             value = bytes_or_str.decode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of str
   #+end_src
  
   #+begin_src python 
     def to_bytes(bytes_or_str) -> bytes:
         if isinstance(bytes_or_str, str):
             value = bytes_or_str.encode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of bytes
   #+end_src
   
   - In Python 3, =bytes= contains a sequence of 8-bit values, =str= contains sequences of Unicode chars. =bytes= and =str= instances can't be used together with operators (like =>= or =+=).
   - In Python 2, =str= contains sequences of 8-bit values, =unicode= contains sequences of Unicode chars. =str= and =unicode= /can/ be used together with operators if the =str= only contains 7-bit ASCII chars.
   - Use helper functions to ensure that the inputs you operate on are the type of char sequence you expect.
   - *If you want to read or write binary data to/from a file, always open the file using a binary mode (like ='rb'= or ='wb'=).

** DONE 4. Write Helper Functions Instead of Complex Expressions
   CLOSED: [2019-05-29 Wed 22:07]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:07]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:07]
   Amen.

   #+begin_src python
     red = int(some_dict.get('red'), [''])[0] or 0) # bad

     # --------------------------

     red = some_dict.get('red', [''])
     red = int(red[0]) if red[0] else 0  # better, but still bad

     # --------------------------

     red = some_dict.get('red', [''])  # better, but verbose
     if red[0]:
         red = int(red[0])
     else:
         red = 0

     # --------------------------

     def get_first_int(some_dict, key, default=0):
         found = values.get(key, [''])
         if found[0]:
             found = int(found[0])
         else:
             found = default
         return found

     red = get_first_int(some_dict, 'red', 0)  # best.
   #+end_src

** DONE 5. Know how to Slice Sequences
   CLOSED: [2019-05-29 Wed 22:44]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:44]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:44]
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     print('First Four: ', a[:4])
     print('Last Four: ', a[-4:])
     print('Middle Two: ', a[3:-3])

     # Leave out the zero index, because it's visual noise
     assert a[:5] == a[0:5]

     # Leave out the final index, because it's redundant
     assert a[5:] == a[5:len(a)]

     # Prefer clarity
     # a[start(inclusive):end(exclusive)]
     a[:]         # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     a[:5]        # ['a', 'b', 'c', 'd', 'e']
     a[:-1]       # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
     a[4:]        #                     ['e', 'f', 'g', 'h']
     a[-3:]       #                          ['f', 'g', 'h']
     a[2:5]       #           ['c', 'd', 'e']
     a[2:-1]      #           ['c', 'd', 'e', 'f', 'g']
     a[-3:-1]     #                          ['f', 'g']
   #+end_src

   #+RESULTS:
   | f | g |

   Negative numbers =n= for the slice implies =len(a)-n=. Therefore

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     assert a[-3:-1] == a[len(a)-3:len(a)-1] # == a[5:7]
   #+end_src

   Create new lists from slices. Splice lists into lists.

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     b = [4:]             # ['e', 'f', 'g', 'h']  NEW list
     b[1] = 99            # ['e', 99, 'g', 'h']
     print(a)             # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     # Inject lists into lists

     a[2:7] = [1, 2, 3]   # ['a', 'b', 1, 2, 3, 'h']
   #+end_src

   - Don't be verbose -> =a[:5]= over =a[0:5]=
   - Slices won't give an IndexError if you slice out of range
   - Slices return a new list
   - Assigning to a =list= slice will replace that range in the original sequence with what's referenced even if their lengths differ.

** DONE 6. Avoid Using =start=, =end=, and =stride= in a Single Slice
   CLOSED: [2019-05-30 Thu 22:40]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:40]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:40]
   What is =stride= used for? Taking every /nth/ item when slicing a sequence.

   =somelist[start:end:stride]=
   
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     evens = a[::2]              # ['a', 'c', 'e', 'g']
     odds = a[1::2]              # ['b', 'd', 'f', 'h']
     undesireable = a[1::-1]     # ['b', 'a'] 

     undesireable
   #+end_src

   #+RESULTS:
   | b | a |

   *Takeaways*
   
   - Specify =start=, =end=, and =stride= in a slice can be confusing.
   - Prefer using /positive/ =stride= values in slices without =start= or =end= indexes.
   - Avoid negative =stride= values.
   - Avoid using =start=, =end=, and =stride= together in a single slice. If you need both operations, use two assignments.

** DONE 7. Use List Comprehensions Instead of =map= and =filter=
   CLOSED: [2019-05-30 Thu 22:54]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:54]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:54]
   /List Comprehensions/ are expressions that derive one list from another.
   
   #+begin_src python :session output drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = [x**2 for x in a]
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |


   Using the =map= built-in, we can achive the same result.

   #+begin_src python :session output drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = map(lambda x: x**2, a)
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |

   Filtering a /list comprehension/ is more concise than =map=/=filter=.

   #+begin_src python :session drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     lc_even_squares = [x**2 for x in a if x % 2 == 0] # Concise!
     mf_even_squares = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)) # VERBOSE
   #+end_src

   *Takeaways*

   - List comprehensions are clearer than =map= and =filter= because no need for =lambda=.
   - List comprehensions allow you to skip items from the list. =map= can't without =filter= and =lambda=s
   - Dicts and =sets= also support comprehension expressions.

** DONE 8. Avoid More Than Two Expressions in List Comprehensions
   CLOSED: [2019-05-31 Fri 22:33]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 22:33]
   - State "IN-PROGRESS" from "TODO"       [2019-05-31 Fri 22:28]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 22:26]--[2019-05-31 Fri 22:33] =>  0:07
   :END:

   Using two list comprehensions to flatten a matrix.

   #+begin_src python :session 
     matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     flat = [x for row in matrix for x in row]
     flat
   #+end_src

   #+RESULTS:
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

   This is readable and simple, but any more than two, and it starts to get messy.

   *Takeaways*
   
   While list comprehensions support multiple levels of loops and multiple conditions per loop level, any more than two should are difficult to read and be avoided. 

** DONE 9. Consider Generator Expressions for Large Comprehensions
   CLOSED: [2019-05-31 Fri 22:56]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 22:56]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 22:34]--[2019-05-31 Fri 22:56] =>  0:22
   :END:

   List comprehensions create a new list based off of the expressions.
   While this is good for small lists, it could end up consuming significant amounts of memory for large lists.

   #+begin_src python :session
     val = [len(x) for x in open('/tmp/small_file.txt')]
     print(val) # not bad for small files, but horrible for large files.
   #+end_src
   
   Prefer generators, which return an iterator instead of a new list. 
   
   #+begin_src python :session :results output
     iter = (len(x) for x in ['hello', 'how', 'do', 'you', 'do'])
     print(next(iter))   # len('hello')
     print(next(iter))   # len('how')
     print(next(iter))   # len('do')
   #+end_src

   #+RESULTS:
   : 5
   : 3
   : 2

   Compose Generators
   
   #+begin_src python :session :results output
     iter = (len(x) for x in ['hello', 'how', 'do', 'you', 'do'])
     roots = ((x, x**0.5) for x in iter)
     print(next(roots)) # next(roots) also advances iter
     print(next(roots))
     print(next(roots))
   #+end_src

   #+RESULTS:
   : (5, 2.23606797749979)
   : (3, 1.7320508075688772)
   : (2, 1.4142135623730951)

   *Takeaways*
   
   - Memory is a limitation with list comprehensions.
   - Generator expressions produce outputs one at a time, which avoids memory issues.
   - Generators expressions can be composed by passing an interator from a generator into the =for= of another.
   - Generator expressions are /fast/ when chained together.

** DONE 10. Prefer =enumerate= over =range=
   CLOSED: [2019-05-31 Fri 23:22]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 23:22]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 23:08]--[2019-05-31 Fri 23:22] =>  0:14
   :END:

   Use =range= for loops that iterate over a set of integers.

   #+begin_src python :session 
     random_bits = 0
     for i in range(64):
         if randint(0, 1):
             random_bits |= 1 << i
   #+end_src

   For data structures you need to iterate over, loop directly over the sequence.

   #+begin_src python :session :results output :exports both
     people = ['george', 'joe', 'harry', 'ivy']
     for person in people:
         print('%s is a person' % person)
   #+end_src

   #+RESULTS:
   : george is a person
   : joe is a person
   : harry is a person
   : ivy is a person

   Prefer =enumerate= over =range= when you need the index along with the data.
   
   #+begin_src python :session :results output :exports both
     people = ['george', 'joe', 'harry', 'ivy']
     for i in range(len(people)):
         print('%d: %s' % (i + 1, people[i])) # Pretty horrible

     for i, person in enumerate(people):
         print('%d: %s' % (i + 1, person)) # Pretty nice

     for i, person in enumerate(people, 1): # Start i at 1
         print('%d: %s' % (i, person)) # Pretty nice without arithmetic
   #+end_src

   #+RESULTS:
   #+begin_example
   1: george
   2: joe
   3: harry
   4: ivy
   1: george
   2: joe
   3: harry
   4: ivy
   1: george
   2: joe
   3: harry
   4: ivy
   #+end_example

   *Takeaways*

   - =enumerate= provides concise syntax for looping over an iterator and getting the index of each item from the iterator as you go.
   - Prefer =enumerate= over =range= and avoid indexing into a sequence.
   - =enumerate(iterable, {start_count})= supply a second param to =enumerate= to specify a starting count.

** DONE 11. Use =zip= to Process Iterators in Parallel
   CLOSED: [2019-06-01 Sat 23:08]
   - State "DONE"       from "IN-PROGRESS" [2019-06-01 Sat 23:08]
   :LOGBOOK:
   CLOCK: [2019-06-01 Sat 22:54]--[2019-06-01 Sat 23:08] =>  0:14
   :END:

   Iterate over multiple lists in parallel efficiently (in Python 3)

   #+begin_src python :session 
     names = ['George', 'Ella', 'Mary']
     letters = [len(n) for n in names]

     # find the longest name, with range and messy code
     longest_name = None
     max_letters = 0

     for i in range(len(names)):
         count = letters[i]
         if count > max_letters:
             longest_name = names[i]
             max_letters = count

     print(longest_name)

     # slightly better using enumerate
     for i, name in enumerate(names):
         count = letters[i]
         if count > max_letters:
             longest_name = name # Fixed an index retrieval here
             max_letters = count

     # Just use zip
     for name, count in zip(names, letters):
         if count > max_letters:
             longest_name = name
             max_letters = count
   #+end_src

   *Takeaways*
   
   - =zip= can be used to iterate over multiple iterators in parallel
   - =zip= is a /lazy/ generator that produces tuples in Python 3. In Python 2 returns the full result as a list of tuples (Memory!)
   - =zip= truncates it output for lists of different lengths
   - Use =zip_longest= from =itertools= to iterate multiple iterators in parallel regardless of mismatched lengths

** DONE 12. Avoid =else= Blocks After =for= and =while= Loops
   CLOSED: [2019-06-03 Mon 22:31]
   - State "DONE"       from "IN-PROGRESS" [2019-06-03 Mon 22:31]
   :LOGBOOK:
   CLOCK: [2019-06-03 Mon 22:21]--[2019-06-03 Mon 22:31] =>  0:10
   :END:

   While you could put =else= after =for= and =while=, why on earth would you do so?
   
   #+begin_src python :session :results output :export both
     for i in range(3):
         print('%d' % i)
     else:
         print('why?!!!') # this runs when the loop is finished
   #+end_src

   #+RESULTS:
   : 0
   : 1
   : 2
   : why?!!!

   What it really means is: If the loop is done, hit the =else=.

   #+begin_src python :session :results output :export both
     for i in range(3):
         print('%d' % i)
         if i == 1:
             break
     else:
         print('why?!!!') # Does not get hit because the loop did not "finish"
   #+end_src

   #+RESULTS:
   : 0
   : 1

   *Takeaways*
   
   - Python supports an =else= after =for= and =while= loops
   - =else= runs if the loop did not encounter a =break=
   - Avoid =else= after loops because it is not intuitive

** DONE 13. Take Advantage of Each Block in =try/except/else/finally=
   CLOSED: [2019-06-04 Tue 23:05]
   - State "DONE"       from "IN-PROGRESS" [2019-06-04 Tue 23:05]
   :LOGBOOK:
   CLOCK: [2019-06-04 Tue 22:45]--[2019-06-04 Tue 23:05] =>  0:20
   :END:

   Finally Blocks: Primarily for cleanup code. Common Example:
   
   #+begin_src python :session
     handle = open('/tmp/something.txt')   # Exceptions here should bubble up and skip the finally below
     try:
         data = handle.read()
     finally:
         handle.close()  # Always runs after try:
   #+end_src

   Use =else= when you want to perform some operation if no exceptions occur

   #+begin_src python :session
     def load_json_key(data, key):
         try:
             result_dict = json.loads(data)    # May raise ValueError
         except ValueError as e:
             raise KeyError from e
         else:
             return result_dict[key]           # May raise KeyError (Bubble up)
   #+end_src

   Keeping everything in one compound statement:
   
   #+begin_src python :session
     UNDEFINED = object()

     def divide_json(path):
         handle = open(path, 'r+')   # May raise IOError (Bubble up)
         try:
             data = handle.read()    # May raise UnicodeDecodeError (Bubble up)
             op = json.loads(data)   # May raise ValueError (Bubble up)
             value = (
                 op['numerator'] /
                 op['denominator'])  # May raise ZeroDivisionError
         except ZeroDivisionError as e:
             return UNDEFINED
         else:
             op['result'] = value
             result = json.dumps(op)
             handle.seek(0)
             handle.write(result)    # May raise IOError (Bubble up)
             return value
         finally:
             handle.close()          # Always runs
   #+end_src

   *Takeaways*

   - =try/finally= lets you run cleanup code regardless whether exceptions were raised in the =try= block
   - =else= helps minimizes the code in =try= blocks and visually distinguish the success case from the =try/except= blocks
   - An =else= block can be used to perform additional actions after a successful =try= block but before common cleanup in a =finally=

     
* Functions

** DONE 14. Prefer Exceptions to Returning =None=
   CLOSED: [2019-06-05 Wed 22:18]
   - State "DONE"       from "IN-PROGRESS" [2019-06-05 Wed 22:18]
   :LOGBOOK:
   CLOCK: [2019-06-05 Wed 22:00]--[2019-06-05 Wed 22:18] =>  0:18
   :END:

   In some cases, returning =None= is error prone. 
   
   #+begin_src python :session :results output
     def divide(a, b):
         try:
             return a / b
         except ZeroDivisionError:
             return None

     # Consuming this way *could* work

     result = divide(x, y)
     if result is None:
         print('Invalid inputs')

     # Consuming this way is incorrect

     result = divide(0, 5)  # Evaluates to 0
     if not result:
         print('Invalid inputs') # WRONG!
   #+end_src

   One way to reduce the chance of errors

   #+begin_src python :session :results output
     def divide(a, b):
         try:
             return True, a / b
         except ZeroDivisionError:
             return False, None

     # Consuming

     success, result = divide(x, y)
     if not success:
         print('Invalid Inputs')

     # But, it allows consumers to skip the success portion like:

     _, result = divide(x, y)
     if not result:
         print('Invalid Inputs')
   #+end_src


   The better way

   #+begin_src python :session :results output
     def divide(x, y):
         try:
             return x / y
         except ZeroDivisionError as e:
             raise ValueError('Invalid inputs') from e

     # Let the consumer handle the error

     try:
         result = divide(5, 2)
     except ValueError:
         print('Invalid Inputs')
     else:
         print('Result is %.1f' % result)
   #+end_src

   #+RESULTS:
   : Python 3.6.2 (default, Feb 25 2018, 09:55:00) 
   : [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin
   : Type "help", "copyright", "credits" or "license" for more information.
   : Result is 2.5
   
   *Takeaways*

   - Functions that return =None= to indicate special meaning are error prone because =None= and other values (0, '') all evaluate to =False= in conditional expressions
   - Raise exceptions to indicate special situations instead of returning =None=. Expect the calling code to handle exceptions properly when they're documented

** TODO 15. Know How Closures Interact with Variable Scope
** TODO 16. Consider Generators Instead of Returning Lists
** TODO 17. Be Defensive When Iterating Over Arguments
** TODO 18. Reduce Visual Noise with Variable Positional Arguments
** TODO 19. Provide Optional Behavior with Keyword Arguments
** TODO 20. Use None and Docstrings to Specify Dynamic Default Arguments
** TODO 21. Enforce Clarity with Keyword-Only Arguments

* Classes and Inheritance

* Metaclasses and Attributes

* Concurrency and Parallelism

* Built-in Modules

* Collaboration

* Production
  
* Time

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-06-05 Wed 22:18]
| Headline                                     |   Time |      |
|----------------------------------------------+--------+------|
| *Total time*                                 | *1:45* |      |
|----------------------------------------------+--------+------|
| Pythonic Thinking                            |   1:27 |      |
| \_  8. Avoid More Than Two Expressions in... |        | 0:07 |
| \_  9. Consider Generator Expressions for... |        | 0:22 |
| \_  10. Prefer =enumerate= over =range=      |        | 0:14 |
| \_  11. Use =zip= to Process Iterators in... |        | 0:14 |
| \_  12. Avoid =else= Blocks After =for=...   |        | 0:10 |
| \_  13. Take Advantage of Each Block in...   |        | 0:20 |
| Functions                                    |   0:18 |      |
| \_  14. Prefer Exceptions to Returning...    |        | 0:18 |
#+END:
