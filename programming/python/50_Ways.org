#+TITLE: 59 Ways To Improve Python
#+STARTUP: logdone
#+OPTIONS: toc:2 num:nil
#+TODO: TODO IN-PROGRESS | DONE(!)

* Pythonic Thinking

** DONE 1. Know Which Version of Python You're Using
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_src sh
     python --version
     python3 --version
     which python
   #+end_src

   #+RESULTS:
   | Python                            | 3.6.2 |
   | Python                            | 3.6.2 |
   | /Users/------/.pyenv/shims/python |       |

** DONE 2. Follow the PEP (Python Enhancement Proposal) 8 Style Guide
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_quote
   Don't do this manually, use a tool like =autopep8= and =pylint=.
   #+end_quote

*** Naming
    
    - Functions, variables, and attributes should be in =lowercase_underscore= format.
    - Protected instance attributes should be in =_leading_underscore= format.
    - Private instance attributes should be in =__double_leading_underscore= format.
    - Classes and exceptions should be in =CapitalizedWord= format.
    - Module-level constants should be in =ALL_CAPS= format.
    - Instance methods in classes should use =self= as the name of the first parameter (which refers to the object).
    - Class methods should use =cls= as the name of the first parameter (which refers to the class). 

*** Expressions and Statements
    
    - Use inline negation =(if a is not b)= instead of negation of positive expressions =(if not a is b)=
    - Don't check for empty values (like =[]= or =''=) by checking the length =(if len(somelist) == 0=. Use =if not somelist= and assume empty values implicitly evaluate to =False=.
    - The same thing goes for non-empty values (like =[1]= or ='hi'=). The statement =if somelist= is implicitly =True= for non-empty values.
    - Avoid single-line =if= statements, =for= and =while= loops, and =except= compound statements. Spread these over multiple lines for clarity.
    - Always put =import= statements at the top of a file.
    - Always use absolute names for modules when importing them, not names relative to the current module's own path. For example, to import the =foo= module from the =bar= package, you should do =from bar import foo=, not just =import foo=.
    - Imports should be in sections in the following order: standard library modules, third=party modules, your own modules. Each subsection should have imports in alphabetical order.

** DONE 3. Know the Differences Between =bytes=, =str=, and =unicode=
   CLOSED: [2019-05-29 Wed 21:57]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 21:57]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 21:57]
   No need to worry about =unicode= in Python 3. 

   #+begin_src python
     def to_str(bytes_or_str) -> str:
         if isinstance(bytes_or_str, bytes):
             value = bytes_or_str.decode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of str
   #+end_src
  
   #+begin_src python 
     def to_bytes(bytes_or_str) -> bytes:
         if isinstance(bytes_or_str, str):
             value = bytes_or_str.encode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of bytes
   #+end_src
   
   - In Python 3, =bytes= contains a sequence of 8-bit values, =str= contains sequences of Unicode chars. =bytes= and =str= instances can't be used together with operators (like =>= or =+=).
   - In Python 2, =str= contains sequences of 8-bit values, =unicode= contains sequences of Unicode chars. =str= and =unicode= /can/ be used together with operators if the =str= only contains 7-bit ASCII chars.
   - Use helper functions to ensure that the inputs you operate on are the type of char sequence you expect.
   - *If you want to read or write binary data to/from a file, always open the file using a binary mode (like ='rb'= or ='wb'=).

** DONE 4. Write Helper Functions Instead of Complex Expressions
   CLOSED: [2019-05-29 Wed 22:07]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:07]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:07]
   Amen.

   #+begin_src python
     red = int(some_dict.get('red'), [''])[0] or 0) # bad

     # --------------------------

     red = some_dict.get('red', [''])
     red = int(red[0]) if red[0] else 0  # better, but still bad

     # --------------------------

     red = some_dict.get('red', [''])  # better, but verbose
     if red[0]:
         red = int(red[0])
     else:
         red = 0

     # --------------------------

     def get_first_int(some_dict, key, default=0):
         found = values.get(key, [''])
         if found[0]:
             found = int(found[0])
         else:
             found = default
         return found

     red = get_first_int(some_dict, 'red', 0)  # best.
   #+end_src

** DONE 5. Know how to Slice Sequences
   CLOSED: [2019-05-29 Wed 22:44]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:44]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:44]
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     print('First Four: ', a[:4])
     print('Last Four: ', a[-4:])
     print('Middle Two: ', a[3:-3])

     # Leave out the zero index, because it's visual noise
     assert a[:5] == a[0:5]

     # Leave out the final index, because it's redundant
     assert a[5:] == a[5:len(a)]

     # Prefer clarity
     # a[start(inclusive):end(exclusive)]
     a[:]         # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     a[:5]        # ['a', 'b', 'c', 'd', 'e']
     a[:-1]       # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
     a[4:]        #                     ['e', 'f', 'g', 'h']
     a[-3:]       #                          ['f', 'g', 'h']
     a[2:5]       #           ['c', 'd', 'e']
     a[2:-1]      #           ['c', 'd', 'e', 'f', 'g']
     a[-3:-1]     #                          ['f', 'g']
   #+end_src

   #+RESULTS:
   | f | g |

   Negative numbers =n= for the slice implies =len(a)-n=. Therefore

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     assert a[-3:-1] == a[len(a)-3:len(a)-1] # == a[5:7]
   #+end_src

   Create new lists from slices. Splice lists into lists.

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     b = [4:]             # ['e', 'f', 'g', 'h']  NEW list
     b[1] = 99            # ['e', 99, 'g', 'h']
     print(a)             # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     # Inject lists into lists

     a[2:7] = [1, 2, 3]   # ['a', 'b', 1, 2, 3, 'h']
   #+end_src

   - Don't be verbose -> =a[:5]= over =a[0:5]=
   - Slices won't give an IndexError if you slice out of range
   - Slices return a new list
   - Assigning to a =list= slice will replace that range in the original sequence with what's referenced even if their lengths differ.

** DONE 6. Avoid Using =start=, =end=, and =stride= in a Single Slice
   CLOSED: [2019-05-30 Thu 22:40]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:40]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:40]
   What is =stride= used for? Taking every /nth/ item when slicing a sequence.

   =somelist[start:end:stride]=
   
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     evens = a[::2]              # ['a', 'c', 'e', 'g']
     odds = a[1::2]              # ['b', 'd', 'f', 'h']
     undesireable = a[1::-1]     # ['b', 'a'] 

     undesireable
   #+end_src

   #+RESULTS:
   | b | a |

   *Takeaways*
   
   - Specify =start=, =end=, and =stride= in a slice can be confusing.
   - Prefer using /positive/ =stride= values in slices without =start= or =end= indexes.
   - Avoid negative =stride= values.
   - Avoid using =start=, =end=, and =stride= together in a single slice. If you need both operations, use two assignments.

** DONE 7. Use List Comprehensions Instead of =map= and =filter=
   CLOSED: [2019-05-30 Thu 22:54]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:54]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:54]
   /List Comprehensions/ are expressions that derive one list from another.
   
   #+begin_src python :session output drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = [x**2 for x in a]
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |


   Using the =map= built-in, we can achive the same result.

   #+begin_src python :session output drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = map(lambda x: x**2, a)
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |

   Filtering a /list comprehension/ is more concise than =map=/=filter=.

   #+begin_src python :session drawer
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     lc_even_squares = [x**2 for x in a if x % 2 == 0] # Concise!
     mf_even_squares = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)) # VERBOSE
   #+end_src

   *Takeaways*

   - List comprehensions are clearer than =map= and =filter= because no need for =lambda=.
   - List comprehensions allow you to skip items from the list. =map= can't without =filter= and =lambda=s
   - Dicts and =sets= also support comprehension expressions.

** DONE 8. Avoid More Than Two Expressions in List Comprehensions
   CLOSED: [2019-05-31 Fri 22:33]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 22:33]
   - State "IN-PROGRESS" from "TODO"       [2019-05-31 Fri 22:28]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 22:26]--[2019-05-31 Fri 22:33] =>  0:07
   :END:

   Using two list comprehensions to flatten a matrix.

   #+begin_src python :session 
     matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     flat = [x for row in matrix for x in row]
     flat
   #+end_src

   #+RESULTS:
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

   This is readable and simple, but any more than two, and it starts to get messy.

   *Takeaways*
   
   While list comprehensions support multiple levels of loops and multiple conditions per loop level, any more than two should are difficult to read and be avoided. 

** DONE 9. Consider Generator Expressions for Large Comprehensions
   CLOSED: [2019-05-31 Fri 22:56]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 22:56]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 22:34]--[2019-05-31 Fri 22:56] =>  0:22
   :END:

   List comprehensions create a new list based off of the expressions.
   While this is good for small lists, it could end up consuming significant amounts of memory for large lists.

   #+begin_src python :session
     val = [len(x) for x in open('/tmp/small_file.txt')]
     print(val) # not bad for small files, but horrible for large files.
   #+end_src
   
   Prefer generators, which return an iterator instead of a new list. 
   
   #+begin_src python :session :results output
     iter = (len(x) for x in ['hello', 'how', 'do', 'you', 'do'])
     print(next(iter))   # len('hello')
     print(next(iter))   # len('how')
     print(next(iter))   # len('do')
   #+end_src

   #+RESULTS:
   : 5
   : 3
   : 2

   Compose Generators
   
   #+begin_src python :session :results output
     iter = (len(x) for x in ['hello', 'how', 'do', 'you', 'do'])
     roots = ((x, x**0.5) for x in iter)
     print(next(roots)) # next(roots) also advances iter
     print(next(roots))
     print(next(roots))
   #+end_src

   #+RESULTS:
   : (5, 2.23606797749979)
   : (3, 1.7320508075688772)
   : (2, 1.4142135623730951)

   *Takeaways*
   
   - Memory is a limitation with list comprehensions.
   - Generator expressions produce outputs one at a time, which avoids memory issues.
   - Generators expressions can be composed by passing an interator from a generator into the =for= of another.
   - Generator expressions are /fast/ when chained together.

** DONE 10. Prefer =enumerate= over =range=
   CLOSED: [2019-05-31 Fri 23:22]
   - State "DONE"       from "IN-PROGRESS" [2019-05-31 Fri 23:22]
   :LOGBOOK:
   CLOCK: [2019-05-31 Fri 23:08]--[2019-05-31 Fri 23:22] =>  0:14
   :END:

   Use =range= for loops that iterate over a set of integers.

   #+begin_src python :session 
     random_bits = 0
     for i in range(64):
         if randint(0, 1):
             random_bits |= 1 << i
   #+end_src

   For data structures you need to iterate over, loop directly over the sequence.

   #+begin_src python :session :results output :exports both
     people = ['george', 'joe', 'harry', 'ivy']
     for person in people:
         print('%s is a person' % person)
   #+end_src

   #+RESULTS:
   : george is a person
   : joe is a person
   : harry is a person
   : ivy is a person

   Prefer =enumerate= over =range= when you need the index along with the data.
   
   #+begin_src python :session :results output :exports both
     people = ['george', 'joe', 'harry', 'ivy']
     for i in range(len(people)):
         print('%d: %s' % (i + 1, people[i])) # Pretty horrible

     for i, person in enumerate(people):
         print('%d: %s' % (i + 1, person)) # Pretty nice

     for i, person in enumerate(people, 1): # Start i at 1
         print('%d: %s' % (i, person)) # Pretty nice without arithmetic
   #+end_src

   #+RESULTS:
   #+begin_example
   1: george
   2: joe
   3: harry
   4: ivy
   1: george
   2: joe
   3: harry
   4: ivy
   1: george
   2: joe
   3: harry
   4: ivy
   #+end_example

   *Takeaways*

   - =enumerate= provides concise syntax for looping over an iterator and getting the index of each item from the iterator as you go.
   - Prefer =enumerate= over =range= and avoid indexing into a sequence.
   - =enumerate(iterable, {start_count})= supply a second param to =enumerate= to specify a starting count.

** TODO 11. Use =zip= to Process Iterators in Parallel

** TODO 12. Avoid =else= Blocks After =for= and =while= Loops

** TODO 13. Take Advantage of Each Block in =try/except/else/finally=

* Functions

* Classes and Inheritance

* Metaclasses and Attributes

* Concurrency and Parallelism

* Built-in Modules

* Collaboration

* Production

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-05-31 Fri 23:22]
| Headline                                     | Time   |      |
|----------------------------------------------+--------+------|
| *Total time*                                 | *0:43* |      |
|----------------------------------------------+--------+------|
| Pythonic Thinking                            | 0:43   |      |
| \_  8. Avoid More Than Two Expressions in... |        | 0:07 |
| \_  9. Consider Generator Expressions for... |        | 0:22 |
| \_  10. Prefer =enumerate= over =range=      |        | 0:14 |
#+END:
