#+TITLE: 59 Ways To Improve Python
#+STARTUP: logdone
#+TODO: TODO IN-PROGRESS(!) | DONE(!)

* Pythonic Thinking

** DONE 1. Know Which Version of Python You're Using
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_src sh
     python --version
     python3 --version
     which python
   #+end_src

   #+RESULTS:
   | Python                            | 3.6.2 |
   | Python                            | 3.6.2 |
   | /Users/------/.pyenv/shims/python |       |

** DONE 2. Follow the PEP (Python Enhancement Proposal) 8 Style Guide
   CLOSED: [2019-05-28 Tue 10:35]

   #+begin_quote
   Don't do this manually, use a tool like =autopep8= and =pylint=.
   #+end_quote

*** Naming
    
    - Functions, variables, and attributes should be in =lowercase_underscore= format.
    - Protected instance attributes should be in =_leading_underscore= format.
    - Private instance attributes should be in =__double_leading_underscore= format.
    - Classes and exceptions should be in =CapitalizedWord= format.
    - Module-level constants should be in =ALL_CAPS= format.
    - Instance methods in classes should use =self= as the name of the first parameter (which refers to the object).
    - Class methods should use =cls= as the name of the first parameter (which refers to the class). 

*** Expressions and Statements
    
    - Use inline negation =(if a is not b)= instead of negation of positive expressions =(if not a is b)=
    - Don't check for empty values (like =[]= or =''=) by checking the length =(if len(somelist) == 0=. Use =if not somelist= and assume empty values implicitly evaluate to =False=.
    - The same thing goes for non-empty values (like =[1]= or ='hi'=). The statement =if somelist= is implicitly =True= for non-empty values.
    - Avoid single-line =if= statements, =for= and =while= loops, and =except= compound statements. Spread these over multiple lines for clarity.
    - Always put =import= statements at the top of a file.
    - Always use absolute names for modules when importing them, not names relative to the current module's own path. For example, to import the =foo= module from the =bar= package, you should do =from bar import foo=, not just =import foo=.
    - Imports should be in sections in the following order: standard library modules, third=party modules, your own modules. Each subsection should have imports in alphabetical order.

** DONE 3. Know the Differences Between =bytes=, =str=, and =unicode=
   CLOSED: [2019-05-29 Wed 21:57]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 21:57]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 21:57]
   No need to worry about =unicode= in Python 3. 

   #+begin_src python
     def to_str(bytes_or_str) -> str:
         if isinstance(bytes_or_str, bytes):
             value = bytes_or_str.decode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of str
   #+end_src
  
   #+begin_src python 
     def to_bytes(bytes_or_str) -> bytes:
         if isinstance(bytes_or_str, str):
             value = bytes_or_str.encode('utf-8')
         else:
             value = bytes_or_str
         return value # Instance of bytes
   #+end_src
   
   - In Python 3, =bytes= contains a sequence of 8-bit values, =str= contains sequences of Unicode chars. =bytes= and =str= instances can't be used together with operators (like =>= or =+=).
   - In Python 2, =str= contains sequences of 8-bit values, =unicode= contains sequences of Unicode chars. =str= and =unicode= /can/ be used together with operators if the =str= only contains 7-bit ASCII chars.
   - Use helper functions to ensure that the inputs you operate on are the type of char sequence you expect.
   - *If you want to read or write binary data to/from a file, always open the file using a binary mode (like ='rb'= or ='wb'=).

** DONE 4. Write Helper Functions Instead of Complex Expressions
   CLOSED: [2019-05-29 Wed 22:07]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:07]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:07]
   Amen.

   #+begin_src python
     red = int(some_dict.get('red'), [''])[0] or 0) # bad

     # --------------------------

     red = some_dict.get('red', [''])
     red = int(red[0]) if red[0] else 0  # better, but still bad

     # --------------------------

     red = some_dict.get('red', [''])  # better, but verbose
     if red[0]:
         red = int(red[0])
     else:
         red = 0

     # --------------------------

     def get_first_int(some_dict, key, default=0):
         found = values.get(key, [''])
         if found[0]:
             found = int(found[0])
         else:
             found = default
         return found

     red = get_first_int(some_dict, 'red', 0)  # best.
   #+end_src

** DONE 5. Know how to Slice Sequences
   CLOSED: [2019-05-29 Wed 22:44]

   - State "DONE"       from "IN-PROGRESS" [2019-05-29 Wed 22:44]
   - State "IN-PROGRESS" from "TODO"       [2019-05-29 Wed 22:44]
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     print('First Four: ', a[:4])
     print('Last Four: ', a[-4:])
     print('Middle Two: ', a[3:-3])

     # Leave out the zero index, because it's visual noise
     assert a[:5] == a[0:5]

     # Leave out the final index, because it's redundant
     assert a[5:] == a[5:len(a)]

     # Prefer clarity
     # a[start(inclusive):end(exclusive)]
     a[:]         # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     a[:5]        # ['a', 'b', 'c', 'd', 'e']
     a[:-1]       # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
     a[4:]        #                     ['e', 'f', 'g', 'h']
     a[-3:]       #                          ['f', 'g', 'h']
     a[2:5]       #           ['c', 'd', 'e']
     a[2:-1]      #           ['c', 'd', 'e', 'f', 'g']
     a[-3:-1]     #                          ['f', 'g']
   #+end_src

   #+RESULTS:
   | f | g |

   Negative numbers =n= for the slice implies =len(a)-n=. Therefore

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     assert a[-3:-1] == a[len(a)-3:len(a)-1] # == a[5:7]
   #+end_src

   Create new lists from slices. Splice lists into lists.

   #+begin_src python
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     b = [4:]             # ['e', 'f', 'g', 'h']  NEW list
     b[1] = 99            # ['e', 99, 'g', 'h']
     print(a)             # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

     # Inject lists into lists

     a[2:7] = [1, 2, 3]   # ['a', 'b', 1, 2, 3, 'h']
   #+end_src

   - Don't be verbose -> =a[:5]= over =a[0:5]=
   - Slices won't give an IndexError if you slice out of range
   - Slices return a new list
   - Assigning to a =list= slice will replace that range in the original sequence with what's referenced even if their lengths differ.

** DONE 6. Avoid Using =start=, =end=, and =stride= in a Single Slice
   CLOSED: [2019-05-30 Thu 22:40]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:40]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:40]
   What is =stride= used for? Taking every /nth/ item when slicing a sequence.

   =somelist[start:end:stride]=
   
   #+begin_src python :session example
     a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
     evens = a[::2]              # ['a', 'c', 'e', 'g']
     odds = a[1::2]              # ['b', 'd', 'f', 'h']
     undesireable = a[1::-1]     # ['b', 'a'] 

     undesireable
   #+end_src

   #+RESULTS:
   | b | a |

   - Specify =start=, =end=, and =stride= in a slice can be confusing.
   - Prefer using /positive/ =stride= values in slices without =start= or =end= indexes.
   - Avoid negative =stride= values.
   - Avoid using =start=, =end=, and =stride= together in a single slice. If you need both operations, use two assignments.

** DONE 7. Use List Comprehensions Instead of =map= and =filter=
   CLOSED: [2019-05-30 Thu 22:54]

   - State "DONE"       from "IN-PROGRESS" [2019-05-30 Thu 22:54]
   - State "IN-PROGRESS" from "TODO"       [2019-05-30 Thu 22:54]
   /List Comprehensions/ are expressions that derive one list from another.
   
   #+begin_src python :session example
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = [x**2 for x in a]
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |


   Using the =map= built-in, we can achive the same result.

   #+begin_src python :session example
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     squares = map(lambda x: x**2, a)
     squares
   #+end_src

   #+RESULTS:
   | 1 | 4 | 9 | 16 | 25 | 36 | 49 | 64 | 81 | 100 |

   Filtering a /list comprehension/ is more concise than =map=/=filter=.

   #+begin_src python :session example
     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     lc_even_squares = [x**2 for x in a if x % 2 == 0] # Concise!
     mf_even_squares = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)) # VERBOSE
   #+end_src

   #+RESULTS:

   - List comprehensions are clearer than =map= and =filter= because no need for =lambda=.
   - List comprehensions allow you to skip items from the list. =map= can't without =filter= and =lambda=s
   - Dicts and =sets= also support comprehension expressions.

** TODO 8. Avoid More Than Two Expressions in List Comprehensions

** TODO 9. Consider Generator Expressions for Large Comprehensions

** TODO 10. Prefer =enumerate= over =range=

** TODO 11. Use =zip= to Process Iterators in Parallel

** TODO 12. Avoid =else= Blocks After =for= and =while= Loops

** TODO 13. Take Advantage of Each Block in =try/except/else/finally=

* Functions

* Classes and Inheritance

* Metaclasses and Attributes

* Concurrency and Parallelism

* Built-in Modules

* Collaboration

* Production
